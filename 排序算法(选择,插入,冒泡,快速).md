# 1.选择排序

当我们用选择排序来排序一组数据时，可以将其过程比作在一列数中找到最小值，然后把它放在第一个位置，接着在剩下的数中找到最小值，放在第二个位置，以此类推，直到整个列都排好序为止。

1. **找到最小值：** 从未排序的数中找到最小的数。
2. **交换位置：** 将最小的数与未排序部分的第一个数交换位置，使其成为已排序部分的一部分。
3. **扩展已排序部分：** 现在，第一个位置已经是最小的数了。
4. **重复：** 重复以上步骤，找到未排序部分的最小值，并将其放在已排序部分的末尾。
5. **完成：** 当所有数都被放在正确的位置上，排序完成。

选择排序的特点是每一轮选择只会交换一次元素的位置，相对于其他排序算法，它的交换次数较少。然而，由于其每一轮都需要在未排序部分中查找最小（或最大）元素，时间复杂度为O(n^2)，空间复杂度:O(1)**不适用于大规模数据集**。

```java
void selectionSort(int[] nums){
   int len = nums.length;
   for(int i=0; i < len; i++){
      int minIndex = i;
      for(int j = i+1; j<len;j++){
         if(nums[j] < nums[minIndex]){
             nums[minIndex] = nums[j];   
         }
      }
       if(minIndex != i){
        int temp = nums[i];
        nums[i] = nums[minIndex];
        nums[minIndex] = temp;
   }
  }
}
```



# 2.插入排序

插入排序是一种简单直观的排序算法，其基本思想是将待排序的数据分为已排序和未排序两部分，然后逐步将未排序的元素插入到已排序部分的合适位置，最终使整个序列有序。

1. **初始状态：** 将**第一个元素视为已排序部分**，剩余的元素视为未排序部分。
2. **每一轮插入：** 从未排序部分取出一个元素，在**已排序部分中从右向左比较**，找到合适的位置插入该元素，使得插入位置左侧的元素都不大于它。
3. **已排序部分扩展：** 插入完成后，已排序部分的长度增加1，未排序部分的长度减少1。
4. **重复操作：** 重复以上步骤，直到所有元素都被插入到已排序部分。
5. **结束：** 当未排序部分为空时，排序完成。

插入排序的特点是每次插入只会涉及到相邻元素的比较和交换，因此在某些情况下，它比其他排序算法更为高效。它适用于小规模数据集或者已经接近有序的数据集。然而，插入排序的平均时间复杂度为O(n^2)，并不适用于大规模数据集的排序

```java
void insertSort(int[] nums){
   //将第一个元素视为已排序好的，循环从第二个元素开始
    for(int i = 1; i < nums.length; i++){
        //在未排序中取一个元素
        int num = nums[i];
        //已排序好的数组中最后元素的索引
        int j = i - 1;
        while( j >= 0 && nums[j] > num){
            nums[j + 1] = nums[j];
            j--;
        }
        if( j + 1 != i){
            nums[j + 1] = i;
        }
    }
}
```



# 3.冒泡排序

冒泡排序是一种简单直观的排序算法，其基本思想是**重复地遍历要排序的列表，一次比较两个相邻元素，并根据比较结果交换它们的位置，直到整个列表有序。**

1. **比较相邻元素：** 从列表的开头开始，比较相邻的两个元素。

2. **交换位置：** 如果这两个相邻元素的顺序不符合排序的要求（升序或降序），则交换它们的位置。

3. **遍历列表：** 继续遍历列表，重复以上比较和交换的过程，直到整个列表有序。

4. **重复多次：** 上述过程可能需要进行多次，每一次遍历都会将未排序部分的最大（或最小）元素冒泡到列表的末尾。

5. **优化：** 可以加入一个优化，即如果在一次遍历中没有发生元素位置的交换，说明列表已经有序，可以提前结束排序。

   冒泡排序的时间复杂度为O(n^2)，其中n是要排序的元素个数。

   ```java
   void bubbleSort(int[] nums){
       int len = nums.length;
       /*仅剩的最后一个元素必定有序，所以 i>0,而不是i>=0;
         每经过一轮排序，数组的最右端逐渐有序，所以循环是从右到左进行的
       */
       for(int i = len - 1; i > 0; i--){
           boolean swapped = false;
           
          for(int j=0; j < i; j++){
            if (nums[j] > nums[j + 1]) {
             // 交换 nums[j] 与 nums[j + 1]
             int tmp = nums[j];
             nums[j] = nums[j + 1];
             nums[j + 1] = tmp;
             // 表示发生了交换
              swapped = true;
            }
          }
       }
       //如果在某一轮内循环中，没有发现交换，说明数组已经有序，提取结束排序
        if( !swapped){
            break;
        }
       
       
   }
   ```

# 4.快速排序

快速排序是一种高效的排序算法，它采用分治的策略，通过递归地将数据集分成较小的子集，最终将整个数据集排序。

当我们用快速排序来排序一组数据时，可以将其比作整理一手扑克牌的过程：

1. **选择一张牌作为基准：** 从一堆牌中选择一张牌，这就是基准。
2. **分成两堆：** 把其他的牌分成两堆，一堆比基准小，一堆比基准大。
3. **递归处理：** **对每一堆重复上述过程**，选择基准、分成两堆，直到每堆只有一张牌。
4. **合并结果：** 最后，把所有的牌按照大小顺序合并在一起。

这样，通过不断地分割和合并，整理出的牌就是有序的。在快速排序中，每一轮选择基准和分割牌的过程使得大的问题被拆解成小的子问题，最终达到排序的目的。这种分治的思想是快速排序的核心。

快速排序是一种平均情况下时间复杂度为 O(n log n) 的排序算法，其中 n 是数组中元素的个数。快速排序在实践中通常比其他排序算法更快，尤其是对于大规模数据集。

```java
class QuickSort{

  void quickSort(int[] nums, int left, int right){
    if(left >= right) return;
    int pivotIndex = partition(nums,0,nums.length);
    // 递归地对分区的两侧进行快速排序
    quickSort(nums,left,pivotIndex - 1);
    quickSort(nums,pivot + 1, right);
   }
  int partition(int[] nums. int left, int right){
    //选择最右端作为基准
    int pivotVal = nums[right];
    //初始化较小元素的索引
    int index = left;
    for(int i = left; i < right; i++){
        if(nums[i] < = pivotVal){
            swap(nums,index,i);
            index++;
        }
    }
      // 将基准元素放到正确的位置
      swap(nums,index,right);
      return index;
}
    void swap(int[] nums, int left, int right){
        if(left != rigth){
            int temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
        }
    }
}

```

